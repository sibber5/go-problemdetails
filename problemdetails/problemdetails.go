// SPDX-License-Identifier: BSD-3-Clause
// Copyright (c) 2025 sibber (GitHub: sibber5)

package problemdetails

import (
	"bytes"
	"encoding/json"
	errs "errors"
	"fmt"
	"net/http"
)

var (
	GetStatusCode func(*http.Request) int
	GetRequestID  func(*http.Request) string
	GetTraceID    func(*http.Request) string

	ProblemDetailsSchema = "" // The json schema for the problem details response. For example, https://www.rfc-editor.org/rfc/rfc9457.html#name-json-schema-for-http-proble.
)

// This is not meant to be used directly. Only read from if using `problemdetails.ProblemDetailsContext`.
type ProblemDetails struct {
	Schema string `json:"$schema,omitempty"`

	Type     string `json:"type"`               // A URI reference that identifies the problem type.
	Status   int    `json:"status"`             // The HTTP status code generated by the origin server for this occurrence of the problem.
	Title    string `json:"title"`              // A short, human-readable summary of the problem type.
	Detail   string `json:"detail,omitempty"`   // A human-readable explanation specific to this occurrence of the problem.
	Instance string `json:"instance,omitempty"` // A URI reference that identifies the specific occurrence of the problem. It may or may not yield further information if dereferenced.

	RequestId string `json:"requestId,omitempty"` // [AdditionalMember]
	TraceId   string `json:"traceId,omitempty"`   // [AdditionalMember]

	Code   string  `json:"code,omitempty"`   // [AdditionalMember] An API specific error code aiding the provider team understand the error based on their own potential taxonomy or registry.
	Errors []Error `json:"errors,omitempty"` // [AdditionalMember] An array of error details to accompany a problem details response.
}

type Error struct {
	Detail    string `json:"detail"`              // A granular description on the specific error related to a body property, query parameter, path parameters, and/or header.
	Pointer   string `json:"pointer,omitempty"`   // A JSON Pointer to a specific request body property that is the source of error.
	Parameter string `json:"parameter,omitempty"` // The name of the query or path parameter that is the source of error.
	Header    string `json:"header,omitempty"`    // The name of the header that is the source of error.
	Code      string `json:"code,omitempty"`      // A string containing additional provider specific codes to identify the error context.
}

// Writes a problem details http response.
//
// detail: A human-readable explanation specific to this occurrence of the problem.
//
// code: [Optional] An API specific error code aiding the provider team understand the error based on their own potential taxonomy or registry.
//
// errors: [Optional] An array of error details to accompany a problem details response.
//
// Returns error if there were invalid arguments, but writes the problem details response either way.
func Write(w http.ResponseWriter, r *http.Request, status int, detail string, code string, errors ...Error) error {
	var typeUri string
	switch status {
	case http.StatusNotFound:
		typeUri = "https://problems-registry.smartbear.com/not-found"
	case http.StatusUnauthorized:
		typeUri = "https://problems-registry.smartbear.com/unauthorized"
	case http.StatusForbidden:
		typeUri = "https://problems-registry.smartbear.com/forbidden"
	case http.StatusBadRequest:
		typeUri = "https://problems-registry.smartbear.com/bad-request"
	case http.StatusServiceUnavailable:
		typeUri = "https://problems-registry.smartbear.com/service-unavailable"
	case http.StatusInternalServerError:
		typeUri = "https://problems-registry.smartbear.com/server-error"
	default:
		typeUri = "about:blank"
	}

	pd, err := newProblemDetails(
		r,
		typeUri,
		status,
		http.StatusText(status),
		detail,
		code,
		errors,
	)

	marshalJSON(w, pd)

	pdCtx, ok := r.Context().Value(CtxKey).(*Context)
	if ok {
		pdCtx.pd = pd
	}

	// if err != nil {
	// 	slog.WarnContext(r.Context(), fmt.Sprintf("Problem details validation failed:\n%s", err.Error()))
	// }
	return err
}

func newProblemDetails(r *http.Request, typeUri string, status int, title string, detail string, code string, errors []Error) (*ProblemDetails, error) {
	err := validateArgs(r, status, detail, code, errors)

	requestId := ""
	if GetRequestID != nil {
		requestId = GetRequestID(r)
	}
	traceId := ""
	if GetTraceID != nil {
		traceId = GetTraceID(r)
	}

	pd := &ProblemDetails{
		Schema: ProblemDetailsSchema,
		Type:   typeUri,
		Status: status,
		Title:  title,
		Detail: detail,

		RequestId: requestId,
		TraceId:   traceId,

		Code:   code,
		Errors: errors,
	}

	return pd, err
}

func validateArgs(r *http.Request, status int, detail string, code string, errors []Error) error {
	var errStatus error
	if status < 100 || status > 599 {
		errStatus = fmt.Errorf("invalid http status code: %d", status)
	}

	var errCtxStatus error
	if GetStatusCode != nil {
		if ctxStatus := GetStatusCode(r); ctxStatus != status {
			errCtxStatus = fmt.Errorf("unexpected http status code from request context: %d, expected: %d", ctxStatus, status)
		}
	}

	var errDetail error
	const detailMaxLen = 1024
	if len(detail) > detailMaxLen {
		errDetail = fmt.Errorf("argument 'detail' is too long: %d, max length: %d", len(detail), detailMaxLen)
	}

	var errCode error
	const codeMaxLen = 50
	if len(code) > codeMaxLen {
		errCode = fmt.Errorf("argument 'code' is too long: %d, max length: %d", len(code), codeMaxLen)
	}

	var errErrors error
	const errorsMaxLen = 1000
	if len(errors) > errorsMaxLen {
		errErrors = fmt.Errorf("argument 'errors' has too many items: %d, max length: %d", len(errors), errorsMaxLen)
	}

	return errs.Join(errStatus, errCtxStatus, errDetail, errCode, errErrors)
}

func marshalJSON(w http.ResponseWriter, pd *ProblemDetails) {
	buf := &bytes.Buffer{}
	enc := json.NewEncoder(buf)
	enc.SetEscapeHTML(true)
	if err := enc.Encode(pd); err != nil {
		http.Error(w, err.Error(), http.StatusInternalServerError)
		return
	}

	w.Header().Set("Content-Type", "application/problem+json")
	w.WriteHeader(pd.Status)
	w.Write(buf.Bytes()) //nolint:errcheck
}
